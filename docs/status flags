Status flags notes:

// from `inc b`
setFlag(S, bc.h & 0x80);
setFlag(Z, bc.h == 0);
setFlag(H, (old & 0x08) && (bc.h & 0x08 == 0));
setFlag(N, false);
setFlag(PV, old == 0x7F);

The S[ign] flag is simple; it just holds the sign (+ or -) of the result. Z[ero] is just as easy, it is set when the result is 0.
N is just set to false.

No, the interesting ones here are H and PV.

The H flag on the Z80 is set when there is a half-carry - the Z80 has a 4-bit ALU, but since it's emulated using 8-bit numbers, it is slightly more complex.

A half carry means a carry from the low nybble (4 bits) to the high nibble.

Take the number 175 for instance. That is, in binary, 1010 1111.

What happens when you add 1 to it? With 8-bit processing, it is simple:

	1010 1111
+	0000 0001
--------------------
	1011 0000
	
The result is simply 48+128=176. Nothing to it, right? Mostly. See, with four-bit processing, it is a bit more complex.

First, take the lower nybbles and add them together:

	1111
+	0001
------------
1 0000

That is 16 - there's just one problem. As a four bit number, the 1 has nowhere to go - this is a half-carry. The 1 from here is then added to the upper nybbles:

	0001
	1010
+	0000
------------
	1011

Take the lower nybble and append it at the end, and the result is once again 1011 0000, or 176.

In any case in which that 1 is carried from the lower nybbles, the half-carry flag is set true.

So why is the half-carry condition (old & 0x08) && (bc.h & 0x08 == 0) for the `inc b` instruction? There are two important things to note. First, old contains the old value of the b register. Second, bc.h contains the new value of the b register.

There are two components to the logic statement.

1) (old & 0x08)
	This is true whenever the fourth bit of the b register was set before b was incremented
	For instance, with the number 3, it is false, because 3 is 0000 0011.
	And with the number 11, it is true, because 11 is 0000 1011.
2) (bc.h & 0x08 == 0)
	This is true whenever the fourth bit of the b register - after being incremented - is *not* true.
	
How does this equal to a half-carry?

Quite simply, actually. The only case in which a half-carry is generated is when bit four is set and then isn't. Why?

Here's an example situation:

b = 149. 1001 0101.
When 1 is added, this becomes 1001 0110. The only time a half carry is generated is when the lower nybble starts with a 1, and carrying it will set it to 0.

Now, I'll be completely honest. While typing this note it occured to me there is a better way, which is similar to the one used for the PV flag, which will be explained next.

With a normal addition operation, the above check makes sense - it's a quick way to determine if a half carry generated.

However, this scenario entails adding *1* to the register - not an unknown number, *1*.

This is important simply because when adding one, there is (fittingly enough) only one situation in which a half carry is generated. Namely, when the lower nybble is 1111. If any bit is unset, a half carry won't occur.

	1111
+	0001
1 0000

*No other possible situation*. This check can then be optimized into (old & 0x0F == 0x0F).

Let's break this down. First, (old & 0x0F). This *masks* the upper nybble - basically, whether `old` is 0110 1111 or 1010 1111, the higher half is ignored and the result is 0000 1111. Next, instead of the usual check - which ends here - we add `== 0x0F`. Why? Well, normally, we're only checking one bit - `if (old & 0x08)` is true when the fourth bit is set (because it is a non-zero number, which in C++ is considered true). Here though, that isn't the goal. The goal is to check if *all four* bits are set. `== 0x0F` makes sure the result is 0000 1111, not a different number such as 0000 0100 (which would otherwise be considered equally valid).

This leads into a separate question about why such micro-optimizations are important. After all, it's a difference of a few nanoseconds, right? Doesn't mean much, right? Nope. This is a separate topic, so you can look [here](./micro_optimizations.html) for an explanation as to why.

If you check the code, you'll notice the flag has been changed. :)

Next, the PV flag. 


